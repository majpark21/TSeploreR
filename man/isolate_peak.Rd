% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak_extraction.R
\name{isolate_peak}
\alias{isolate_peak}
\title{Isolate peaks}
\usage{
isolate_peak(y, positions, thresh.order1 = 0, include.boundary = TRUE,
  use.second = FALSE, thresh.order22 = NULL, thresh.order12 = NULL,
  out.type = "data.table")
}
\arguments{
\item{y}{A numeric vector, from which to isolate peaks.}

\item{positions}{A vector of integers indicating the index of the tip of the
peaks.}

\item{thresh.order1}{Threshold for 1st derivative. Whenever the walk
encounters a 1st derivative that is bigger than the threshold, stop and
define a peak border. Default to 0, i.e. whenever the signal increases
again, stop and define a border.}

\item{include.boundary}{logical. If TRUE, will use beginning/end of the series
as valid peak border . If FALSE, when a walk from a peak reaches beginning or
end of the series, the peak isolation will be considered as failed.}

\item{use.second}{logical, use 2nd derivative?}

\item{thresh.order22}{If use.second = TRUE. If absolute second derivative is
below this threshold, consider the signal as steady. If thresh.order12 is
also below its threshold at the same time point, stop and define a border.}

\item{thresh.order12}{If use.second = TRUE. If absolute first derivative is
below this threshold, consider the signal as evolving very slowly. If
thresh.order22 is also below its threshold at the same time point, stop and
define a border.}

\item{One}{of c("data.table","list", "vector"). See Return.}
}
\value{
If out.type="data.table", returns a data.table with 2 columns. The
  first one is the signal, the second is a vector indicating to which peak
  the portion of the signal belongs to. In this vector, 0 means that the
  portion of the signal does not belong to any peak, while a number > 0
  indicate that it belongs to a peak. 1 indicates the first peak referred in
  'positions', 2 the second and so on. If for one of the peaks cannot be
  properly isolated, its number is skipped. If out.type="vector", returns
  only the second column of the data.table.
  
  Finally, if out.type="list",
  returns a list of same length as positions. Each element of the list
  posseses 4 elements: $start: starting point of the peak; $center: tip of the
  peak (max amplitude); $end: ending point of the peak; $y: part of the
  signal comprised between $start and $end.
}
\description{
Isolate peaks from a signal based on first (and second derivative). Starting
from the tip of the peak, walk left (then right) until derivatives overcome
thresholds. When this happens, mark a border of the peak. Individual peaks
are delimited by these borders. The rational of using the 2nd derivative is
to stop whenever the signal is steady (low 2nd derivative) and evolving slowly
(low 1st derivative).
}
\examples{
# Curve coming from real-data:
y <- c(1.114, 1.146, 1.106, 1.049, 1.031, 1.01, 1, 0.992, 0.987, 0.981, 1.009, 1.072, 1.053, 1.018, 0.988,
 0.979, 0.965, 0.958, 0.956, 0.942, 0.939, 0.932, 0.926, 0.922, 0.919, 0.919, 0.916, 0.915, 0.918, 0.916,
 0.913, 0.911, 0.907, 0.908, 0.904, 0.905, 0.9, 0.899, 0.899, 0.905, 0.905, 0.908, 0.913, 0.919, 0.919,
 0.911, 0.922, 0.918, 0.916, 0.915, 0.92, 0.917, 0.915, 0.926, 0.964, 1.099, 1.075, 1.018, 0.999, 0.989,
 0.977, 0.975, 0.964, 0.96, 0.958, 0.945, 0.946, 0.944, 0.944, 0.938, 0.934, 0.936, 0.933, 0.926, 0.921,
 0.923, 0.924, 0.926, 0.929, 0.932, 0.926, 0.932, 0.939, 0.941, 0.976, 1.116, 1.09, 1.053, 1.034, 1.019,
 1.038, 1.104, 1.089, 1.059, 1.027, 1.012, 1.009, 1, 0.991, 0.986, 0.973, 0.969, 0.975, 0.966, 0.961,
 0.96, 0.949, 0.946, 0.943, 0.938, 0.942, 0.937, 0.934, 0.936, 0.941, 0.939, 0.97, 0.932, 0.931, 0.941,
 0.944, 0.949, 0.969, 1.048, 1.052, 1.059, 1.103, 1.083, 1.05, 1.036, 1.015, 1.01, 0.997, 0.995, 0.988,
 0.977, 0.979, 0.977, 0.981, 0.982, 0.976, 0.971, 0.97, 0.965, 0.966, 0.967, 0.967, 0.972, 0.904, 0.966,
 0.978, 0.983, 0.979, 0.975, 0.98, 0.973, 0.968, 0.97, 0.962, 0.966, 0.962, 0.968, 0.964, 0.956, 0.963,
 0.954, 0.958, 0.956, 0.958, 0.952, 0.95, 0.952, 0.946, 0.953, 0.952, 0.952, 0.953, 0.952, 0.954, 0.956)
 
 peaks_pos <- extract_peak(y, method = "bump", bp.winlen = 5, bp.mind = 1, recenter = 2, filter.thresh = 0.05, filter.winlen = 10, detect.early = 10)
 peaks <- isolate_peak(y=y, positions=which(peaks_pos$bump), thresh.order1=0, use.second=FALSE, out.type="list")
 plot(y, type = "b", main = "Points are colored according to their respective peaks.")
 abline(v=which(peaks_pos$bump), lty="dashed", col="red")
 col_ind <- 1
 for(peak in peaks){
   if(!any(is.na(c(peak$start, peak$end)))){
     points(peak$start:peak$end, y[peak$start:peak$end], pch=20, col=palette()[col_ind])
     col_ind <- col_ind+1
   }
 }

}
\seealso{
extract_peak
}
